export const SHADER_PREFIX = '#version 300 es\nprecision highp float;\nlayout(std140, column_major) uniform;\n\n';
export const DEFAULT_VERTEX_SHADER = '#ifdef MORPH_TARGETS\n\n  #if MORPH_TARGETS_COUNT > 0\n\n    in vec3 a_position0;\n\n  #endif\n\n  #if MORPH_TARGETS_COUNT > 1\n\n    in vec3 a_position1;\n\n  #endif\n\n  #if MORPH_TARGETS_COUNT > 2\n\n    in vec3 a_position2;\n\n  #endif\n\n  #if MORPH_TARGETS_COUNT > 3\n\n    in vec3 a_position3;\n\n  #endif\n\n  uniform float u_weights[MORPH_TARGETS_COUNT];\n\n#endif\n\n\n#ifdef SKIN\n\n  in vec4 a_joint;\n\n  in vec4 a_weight;\n\n  uniform mat4 u_jointMatrix[SKIN_JOINTS_COUNT];\n\n#endif\n\n\n#if defined(LIGHT) || defined(ENV_MAP)\n\n  in vec3 a_normal;\n\n  #ifdef MORPH_TARGETS\n\n    #if MORPH_TARGETS_COUNT > 0\n\n      in vec3 a_normal0;\n\n    #endif\n\n    #if MORPH_TARGETS_COUNT > 1\n\n      in vec3 a_normal1;\n\n    #endif\n\n    #if MORPH_TARGETS_COUNT > 2\n\n      in vec3 a_normal2;\n\n    #endif\n\n    #if MORPH_TARGETS_COUNT > 3\n\n      in vec3 a_normal3;\n\n    #endif\n\n  #endif\n  uniform mat3 u_normalMatrix;\n\n  out vec3 v_normal;\n\n#endif\n\n\n\n#if defined(NORMAL_MAP)\n\n  in vec4 a_tangent;\n\n  out mat3 v_TBN;\n\n  #ifdef MORPH_TARGETS\n\n    #if MORPH_TARGETS_COUNT > 0\n\n      in vec4 a_tangent0;\n\n    #endif\n\n    #if MORPH_TARGETS_COUNT > 1\n\n      in vec4 a_tangent1;\n\n    #endif\n\n    #if MORPH_TARGETS_COUNT > 2\n\n      in vec4 a_tangent2;\n\n    #endif\n\n    #if MORPH_TARGETS_COUNT > 3\n\n      in vec4 a_tangent3;\n\n    #endif\n\n  #endif\n#endif\n\n\n\n#if defined(DIFFUSE_MAP) || defined(NORMAL_MAP) || defined(BUMP_MAP) || defined(EMISSIVE_MAP) || defined(AMBIENT_MAP) || defined(SPECULAR_MAP)\n\n  in vec2 a_uv;\n\n  uniform mat3 u_textureMatrix;\n\n  out vec2 v_uv;\n\n#endif\n\n\n\n#ifdef WIREFRAME\n\n  in vec3 a_barycentric;\n\n  out vec3 v_barycentric;\n\n#endif\n\n\n#if defined(CLIPPLANE) || defined(DIFFUSE_CUBE_MAP)\n\n  out vec3 v_modelPosition;\n\n#endif\n\n\n#if defined(LIGHT) || defined(FOG) || defined(ENV_MAP)\n\n  out vec3 v_worldPosition;\n\n#endif\n\n\n#ifdef VERTEX_COLOR\n\n  in vec4 a_color;\n\n  out vec4 v_color;\n\n#endif\n\n\n#ifdef SHADOW\n\n  #define CASCADED_COUNT 4\n\n  uniform mat4 u_shadowMapProjectViewMatrix_0;\n\n  uniform mat4 u_shadowMapProjectViewMatrix_1;\n\n  uniform mat4 u_shadowMapProjectViewMatrix_2;\n\n  uniform mat4 u_shadowMapProjectViewMatrix_3;\n\n  out vec4 v_shadowMapPosition[CASCADED_COUNT];\n\n#endif\n\n\n#ifdef POINT\n\n  uniform float u_pointSize;\n\n#endif\n\n\nin vec3 a_position;\n\nuniform mat4 u_projectViewMatrix;\n\nuniform mat4 u_modelMatrix;\n\n\n\nvoid main () {\n\n  vec3 position = a_position;\n\n\n\n  #ifdef MORPH_TARGETS\n\n    #if MORPH_TARGETS_COUNT > 0\n\n      position += a_position0 * u_weights[0];\n\n    #endif\n\n    #if MORPH_TARGETS_COUNT > 1\n\n      position += a_position1 * u_weights[1];\n\n    #endif\n\n    #if MORPH_TARGETS_COUNT > 2\n\n      position += a_position2 * u_weights[2];\n\n    #endif\n\n    #if MORPH_TARGETS_COUNT > 3\n\n      position += a_position3 * u_weights[3];\n\n    #endif\n\n  #endif\n\n\n  vec4 finalPosition = vec4(position, 1.0);\n\n\n\n  #ifdef SKIN\n\n    mat4 skinMat =\n\n      a_weight.x * u_jointMatrix[int(a_joint.x)] +\n\n      a_weight.y * u_jointMatrix[int(a_joint.y)] +\n\n      a_weight.z * u_jointMatrix[int(a_joint.z)] +\n\n      a_weight.w * u_jointMatrix[int(a_joint.w)];\n\n    finalPosition = skinMat * finalPosition;\n\n  #endif\n\n\n  vec4 worldPosition = u_modelMatrix * finalPosition;\n\n  gl_Position = u_projectViewMatrix * worldPosition;\n\n  #ifdef POINT\n\n    gl_PointSize = u_pointSize;\n\n  #endif\n\n\n  #if defined(LIGHT) || defined(FOG) || defined(ENV_MAP)\n\n    v_worldPosition = worldPosition.xyz;\n\n  #endif\n\n\n  #ifdef SHADOW\n\n    v_shadowMapPosition[0] = u_shadowMapProjectViewMatrix_0 * worldPosition;\n\n    v_shadowMapPosition[1] = u_shadowMapProjectViewMatrix_1 * worldPosition;\n\n    v_shadowMapPosition[2] = u_shadowMapProjectViewMatrix_2 * worldPosition;\n\n    v_shadowMapPosition[3] = u_shadowMapProjectViewMatrix_3 * worldPosition;\n\n  #endif\n\n\n  #if defined(LIGHT) || defined(ENV_MAP)\n\n    vec3 finalNormal = a_normal;\n\n    #ifdef MORPH_TARGETS\n\n      #if MORPH_TARGETS_COUNT > 0\n\n        finalNormal += a_normal0 * u_weights[0];\n\n      #endif\n\n      #if MORPH_TARGETS_COUNT > 1\n\n        finalNormal += a_normal1 * u_weights[1];\n\n      #endif\n\n      #if MORPH_TARGETS_COUNT > 2\n\n        finalNormal += a_normal2 * u_weights[2];\n\n      #endif\n\n      #if MORPH_TARGETS_COUNT > 3\n\n        finalNormal += a_normal3 * u_weights[3];\n\n      #endif\n\n    #endif\n    v_normal = u_normalMatrix * finalNormal;\n\n  #endif\n\n\n\n  #if defined(NORMAL_MAP)\n\n    vec4 finalTangent = a_tangent;\n\n    #ifdef MORPH_TARGETS\n\n      #if MORPH_TARGETS_COUNT > 0\n\n        finalTangent += a_tangent0 * u_weights[0];\n\n      #endif\n\n      #if MORPH_TARGETS_COUNT > 1\n\n        finalTangent += a_tangent1 * u_weights[1];\n\n      #endif\n\n      #if MORPH_TARGETS_COUNT > 2\n\n        finalTangent += a_tangent2 * u_weights[2];\n\n      #endif\n\n      #if MORPH_TARGETS_COUNT > 3\n\n        finalTangent += a_tangent3 * u_weights[3];\n\n      #endif\n\n    #endif\n    vec3 normal = normalize(finalNormal);\n\n    vec3 tangent = normalize(finalTangent.xyz);\n\n    vec3 bitangent = cross(normal, tangent) * finalTangent.w;\n\n    v_TBN = mat3(u_modelMatrix) * mat3(tangent, bitangent, normal);\n  #endif\n\n\n\n  #if defined(DIFFUSE_MAP) || defined(NORMAL_MAP) || defined(BUMP_MAP) || defined(EMISSIVE_MAP) || defined(AMBIENT_MAP) || defined(SPECULAR_MAP)\n\n    #ifdef FLIP_Y\n\n      v_uv = (u_textureMatrix * vec3(a_uv.x, 1.0 - a_uv.y, 1.0)).xy;\n\n    #else\n\n      v_uv = (u_textureMatrix * vec3(a_uv, 1.0)).xy;\n\n    #endif\n\n  #endif\n\n\n\n  #ifdef VERTEX_COLOR\n\n    v_color = a_color;\n\n  #endif\n\n\n  #ifdef WIREFRAME\n\n    v_barycentric = a_barycentric;\n\n  #endif\n\n\n  #if defined(CLIPPLANE) || defined(DIFFUSE_CUBE_MAP)\n\n    v_modelPosition = finalPosition.xyz;\n\n  #endif\n}\n\n';
export const DEFAULT_FRAGMENT_SHADER = '#ifdef VERTEX_COLOR\n\n  in vec4 v_color;\n\n#endif\n\n\n#ifdef DIFFUSE_MAP\n\n  uniform sampler2D u_diffuseSampler;\n\n#endif\n\n\n\n#ifdef DIFFUSE_CUBE_MAP\n\n  uniform samplerCube u_diffuseSampler;\n\n#endif\n\n\n\n#if defined(LIGHT) || defined(ENV_MAP)\n\n  in vec3 v_normal;\n\n#endif\n\n\n\n#if defined(DIFFUSE_MAP) || defined(NORMAL_MAP) || defined(BUMP_MAP) || defined(EMISSIVE_MAP) || defined(AMBIENT_MAP) || defined(SPECULAR_MAP)\n\n  in vec2 v_uv;\n\n#endif\n\n\n\n#ifdef ENV_MAP\n\n  uniform samplerCube u_envSampler;\n\n#endif\n\n\n\n#ifdef EMISSIVE_MAP\n\n  uniform sampler2D u_emissiveSampler;\n\n  uniform vec3 u_emissiveColor;\n\n#endif\n\n\n\n#if defined(LIGHT) || defined(FOG) || defined(ENV_MAP)\n\n  uniform vec3 u_eyePosition;\n\n  in vec3 v_worldPosition;\n\n#endif\n\n\n#ifdef LIGHT\n\n  uniform vec3 u_ambientLightColor;\n\n  uniform vec3 u_ambientColor;\n\n  uniform float u_shininess;\n\n\n\n  #ifdef AMBIENT_MAP\n\n    uniform sampler2D u_ambientSampler;\n\n  #endif\n\n  #ifdef SPECULAR_MAP\n\n    uniform sampler2D u_specularSampler;\n\n  #else\n\n    uniform vec3 u_specularColor;\n\n  #endif\n\n  #if defined(NORMAL_MAP)\n\n    uniform sampler2D u_normalSampler;\n\n    in mat3 v_TBN;\n\n  #endif\n\n  \n\n  #if defined(BUMP_MAP)\n\n    uniform sampler2D u_bumpSampler;\n\n    uniform float u_bumpScale;\n\n  \n\n    //Bump Mapping Unparametrized Surfaces on the GPU by Morten S. Mikkelsen\n\n    // http://api.unrealengine.com/attachments/Engine/Rendering/LightingAndShadows/BumpMappingWithoutTangentSpace/mm_sfgrad_bump.pdf\n\n    // https://github.com/mrdoob/three.js/blob/dev/src/renderers/shaders/ShaderChunk/bumpmap_pars_fragment.glsl\n\n    vec3 perturbNormalArb(vec3 surf_pos, vec3 surf_norm) {\n\n      vec2 dSTdx = dFdx(v_uv);\n\n      vec2 dSTdy = dFdy(v_uv);\n\n      float Hll = u_bumpScale * texture(u_bumpSampler, v_uv).x;\n\n      float dBx = u_bumpScale * texture(u_bumpSampler, v_uv + dSTdx).x - Hll;\n\n      float dBy = u_bumpScale * texture(u_bumpSampler, v_uv + dSTdy).x - Hll;\n\n  \n\n      vec3 vSigmaX = vec3(dFdx(surf_pos.x), dFdx(surf_pos.y), dFdx(surf_pos.z));\n\n      vec3 vSigmaY = vec3(dFdy(surf_pos.x), dFdy(surf_pos.y), dFdy(surf_pos.z));\n\n      vec3 vN = surf_norm;\n\n      vec3 R1 = cross(vSigmaY, vN);\n\n      vec3 R2 = cross(vN, vSigmaX);\n\n  \n\n      float fDet = dot(vSigmaX, R1);\n\n      fDet *= (float(gl_FrontFacing) * 2.0 - 1.0);\n\n  \n\n      vec3 vGrad = sign(fDet) * (dBx * R1 + dBy * R2);\n\n      return normalize(abs(fDet) * surf_norm - vGrad);\n\n    }\n\n  #endif\n\n\n  #define PCF_SHADOW\n\n  #ifdef SHADOW\n\n    #define CASCADED_COUNT 4\n\n    in vec4 v_shadowMapPosition[CASCADED_COUNT];\n\n    uniform highp sampler2DArrayShadow u_shadowMapSampler;\n\n    uniform vec4 u_cascadedEnd;\n\n  \n\n    float calculateShadow (int layer) {\n\n      vec3 position = v_shadowMapPosition[layer].xyz / v_shadowMapPosition[layer].w;\n\n      position = position * 0.5 + 0.5;\n\n      vec4 shadowUv = vec4(position.xy, float(layer), position.z - 0.005);\n\n  \n\n      #ifdef PCF_SHADOW\n\n        vec2 size = 1.0 / vec2(2048.0, 2048.0);\n\n        float depth = 0.0;\n\n        for (int x = -1; x <= 1; ++x) {\n\n          for (int y = -1; y <= 1; ++y) {\n\n            shadowUv.xy = position.xy + vec2(x, y) * size;\n\n            float pcfDepth = texture(u_shadowMapSampler, shadowUv);\n\n            depth += pcfDepth;\n\n          }\n\n        }\n\n        depth /= 9.0;\n\n        return depth;\n\n      #else\n\n        float depth = texture(u_shadowMapSampler, shadowUv);\n\n        return depth;\n\n      #endif\n\n    }\n\n  #endif\n\n\n  struct LightInfo {\n\n    vec3 diffuseColor;\n\n    vec3 specularColor;\n\n    // vec3 cascadedColor;\n\n  };\n\n  \n\n  #if DIRECTION_LIGHT_COUNT\n\n    struct DirectionLight {\n\n      vec3 diffuseColor;\n\n      vec3 specularColor;\n\n      vec3 direction;\n\n    };\n\n    uniform DirectionLight u_directionLights[DIRECTION_LIGHT_COUNT];\n\n  \n\n    LightInfo calculateDirectionLightInfo(DirectionLight light, vec3 eyeDirection, vec3 normal) {\n\n      LightInfo info;\n\n      vec3 lightDirection = normalize(-light.direction);\n\n      float ndl = dot(lightDirection, normal);\n\n      float diffuse = max(ndl, 0.0);\n\n      vec3 reflectDirection = reflect(-lightDirection, normal);\n\n      float specular = 0.0;\n\n      if (u_shininess > 0.0) {\n\n        #ifdef NORMAL_MAP\n\n          if (dot(lightDirection, v_normal) > 0.0) {\n\n        #endif\n\n        specular = pow(max(dot(reflectDirection, eyeDirection), 0.0), u_shininess);\n\n        #ifdef NORMAL_MAP\n\n          }\n\n        #endif\n\n      }\n\n  \n\n      #ifdef SHADOW\n\n        int layer = 3;\n\n        // vec3 cascadedColor = vec3(0.0, 0.0, 0.0);\n\n        if (gl_FragCoord.z <= u_cascadedEnd.x) {\n\n          layer = 0;\n\n          // cascadedColor = vec3(0.0, 0.0, 0.2);\n\n        } else if (gl_FragCoord.z <= u_cascadedEnd.y) {\n\n          layer = 1;\n\n          // cascadedColor = vec3(0.0, 0.2, 0.0);\n\n        } else if (gl_FragCoord.z <= u_cascadedEnd.z) {\n\n          layer = 2;\n\n          // cascadedColor = vec3(0.2, 0.0, 0.0);\n\n        }\n\n        float shadow = calculateShadow(layer);\n\n        diffuse *= shadow;\n\n        specular *= shadow;\n\n        // DEBUG:\n\n        // info.cascadedColor = cascadedColor;\n\n      #endif\n\n  \n\n      info.diffuseColor = light.diffuseColor * diffuse;\n\n      info.specularColor = light.specularColor * specular;\n\n      return info;\n\n    }\n\n  #endif\n\n  \n\n  #if POINT_LIGHT_COUNT\n\n    struct PointLight {\n\n      vec3 diffuseColor;\n\n      vec3 specularColor;\n\n      vec3 position;\n\n      float distance;\n\n    };\n\n    uniform PointLight u_pointLights[POINT_LIGHT_COUNT];\n\n  \n\n    LightInfo calculatePointLightInfo(PointLight light, vec3 eyeDirection, vec3 normal) {\n\n      LightInfo info;\n\n      vec3 lightDirection = light.position - v_worldPosition;\n\n      float distance = length(lightDirection);\n\n      lightDirection = normalize(lightDirection);\n\n      float diffuse = max(dot(lightDirection, normal), 0.0);\n\n      vec3 reflectDirection = reflect(-lightDirection, normal);\n\n      float specular = 0.0;\n\n      if (u_shininess > 0.0) {\n\n        #ifdef NORMAL_MAP\n\n          if (dot(lightDirection, v_normal) > 0.0) {\n\n        #endif\n\n        specular = pow(max(dot(reflectDirection, eyeDirection), 0.0), u_shininess);\n\n        #ifdef NORMAL_MAP\n\n          }\n\n        #endif\n\n      }\n\n      float attenuation = 1.0;\n\n      if (light.distance > 0.0) {\n\n        attenuation = max(1.0 - distance / light.distance, 0.0);\n\n      }\n\n      info.diffuseColor = light.diffuseColor * diffuse * attenuation;\n\n      info.specularColor = light.specularColor * specular * attenuation;\n\n      return info;\n\n    }\n\n  #endif\n\n  \n\n  #if SPOT_LIGHT_COUNT\n\n    struct SpotLight {\n\n      vec3 diffuseColor;\n\n      vec3 specularColor;\n\n      vec3 direction;\n\n      vec3 position;\n\n      float distance;\n\n      float innerAngle;\n\n      float outerAngle;\n\n    };\n\n    uniform SpotLight u_spotLights[SPOT_LIGHT_COUNT];\n\n  \n\n    LightInfo calculateSpotLightInfo(SpotLight light, vec3 eyeDirection, vec3 normal) {\n\n      LightInfo info;\n\n      vec3 lightDirection = light.position - v_worldPosition;\n\n      float distance = length(lightDirection);\n\n      lightDirection = normalize(lightDirection);\n\n      float diffuse = max(dot(lightDirection, normal), 0.0);\n\n      vec3 reflectDirection = reflect(-lightDirection, normal);\n\n      float specular = 0.0;\n\n      if (u_shininess > 0.0) {\n\n        #ifdef NORMAL_MAP\n\n          if (dot(lightDirection, v_normal) > 0.0) {\n\n        #endif\n\n        specular = pow(max(dot(reflectDirection, eyeDirection), 0.0), u_shininess);\n\n        #ifdef NORMAL_MAP\n\n          }\n\n        #endif\n\n      }\n\n      float attenuation = 1.0;\n\n      if (light.distance > 0.0) {\n\n        attenuation = max(1.0 - distance / light.distance, 0.0);\n\n      }\n\n      float theta = dot(lightDirection, normalize(-light.direction));\n\n      float epsilon = light.innerAngle - light.outerAngle;\n\n      float intensity = clamp((theta - light.outerAngle) / epsilon, 0.0, 1.0);\n\n      attenuation *= intensity;\n\n      info.diffuseColor = light.diffuseColor * diffuse * attenuation;\n\n      info.specularColor = light.specularColor * specular * attenuation;\n\n      return info;\n\n    }\n\n  #endif\n#endif\n\n\n\n#ifdef WIREFRAME\n\n  uniform vec3 u_wireframeColor;\n\n  uniform float u_wireframeWidth;\n\n  in vec3 v_barycentric;\n\n\n\n  float edgeFactor () {\n\n    vec3 d = fwidth(v_barycentric);\n\n    vec3 a3 = smoothstep(vec3(0.0), d * u_wireframeWidth, v_barycentric);\n\n    return min(min(a3.x, a3.y), a3.z);\n\n  }\n\n#endif\n\n\n#if defined(CLIPPLANE)\n\n  uniform vec4 u_clipPlane;\n\n#endif\n\n\n\n#if defined(CLIPPLANE) || defined(DIFFUSE_CUBE_MAP)\n\n  in vec3 v_modelPosition;\n\n#endif\n\n\n#ifdef FOG\n\n  uniform vec3 u_fogColor;\n\n  uniform float u_fogNear;\n\n  uniform float u_fogFar;\n\n#endif\n\n\n#ifdef ALPHA_TEST\n\n  uniform float u_alphaCutoff;\n\n#endif\n\n\nconst vec3 gammaValue = vec3(2.2);\n\nconst vec3 gammaInvValue = vec3(1.0 / 2.2);\n\n\n\nvec3 gammaInput (vec3 color) {\n\n  #ifdef GAMMA_INPUT\n\n    return pow(color, gammaValue);\n\n  #else\n\n    return color;\n\n  #endif\n\n}\n\n\n\nvec3 gammaOutput (vec3 color) {\n\n  return pow(color, gammaInvValue);\n\n}\n\n\n\n// https://github.com/google/filament/blob/b3d758f3b3fdf91b750a7561a1c729649cf4c1e8/shaders/src/common_graphics.fs\n\nfloat luminance(const vec3 linear) {\n\n  return dot(linear, vec3(0.2126, 0.7152, 0.0722));\n\n}\n\n\n\n// https://github.com/google/filament/blob/b3d758f3b3fdf91b750a7561a1c729649cf4c1e8/shaders/src/tone_mapping.fs\n\nvec3 tonemapACES(const vec3 x) {\n\n  // Narkowicz 2015, "ACES Filmic Tone Mapping Curve"\n\n  const float a = 2.51;\n\n  const float b = 0.03;\n\n  const float c = 2.43;\n\n  const float d = 0.59;\n\n  const float e = 0.14;\n\n  return (x * (a * x + b)) / (x * (c * x + d) + e);\n\n}\n\n\n\n\nuniform vec4 u_diffuseColor;\n\nuniform float u_transparency;\n\nout vec4 fragColor;\n\n\n\nvoid main () {\n\n  #ifdef CLIPPLANE\n\n    float clipDistance = dot(v_modelPosition, u_clipPlane.xyz);\n\n    if (clipDistance >= u_clipPlane.w) {\n\n      discard;\n\n    }\n\n  #endif\n\n\n  #if defined(LIGHT) || defined(FOG) || defined(ENV_MAP)\n\n    vec3 eyeSpacePosition = u_eyePosition - v_worldPosition;\n\n  #endif\n\n\n\n  #if defined(WIREFRAME) && defined(WIREFRAME_ONLY)\n\n    fragColor = vec4(u_wireframeColor, (1.0 - edgeFactor()) * u_transparency);\n\n  #else\n\n    #ifdef DIFFUSE_MAP\n\n      vec4 baseColor = texture(u_diffuseSampler, v_uv);\n\n      baseColor.rgb = gammaInput(baseColor.rgb);\n\n    #else\n\n      #ifdef DIFFUSE_CUBE_MAP\n\n        // http://marcinignac.com/blog/pragmatic-pbr-hdr/\n\n        vec4 baseColor = texture(u_diffuseSampler, normalize(vec3(-v_modelPosition.x, v_modelPosition.y, v_modelPosition.z)));\n\n        baseColor.rgb = gammaInput(baseColor.rgb);\n\n      #else\n\n        vec4 baseColor = vec4(1.0);\n\n      #endif\n\n    #endif\n\n\n\n    #ifdef VERTEX_COLOR\n\n      baseColor *= v_color;\n\n    #endif\n\n\n    #ifdef ALPHA_TEST\n\n      if (baseColor.a < u_alphaCutoff) {\n\n        discard;\n\n      }\n\n      baseColor.a = 1.0;\n\n    #endif\n\n\n    baseColor.a *= u_transparency;\n\n\n\n    vec3 emissiveColor = vec3(0.0);\n\n    #ifdef EMISSIVE_MAP\n\n      emissiveColor = u_emissiveColor * texture(u_emissiveSampler, v_uv).rgb;\n\n    #endif\n\n\n\n    #ifdef LIGHT\n\n      #if defined(NORMAL_MAP)\n\n        vec3 normal = normalize((texture(u_normalSampler, v_uv) * 2.0 - 1.0).rgb);\n\n        normal = normalize(v_TBN * normal);\n\n      #else\n\n        #if defined(BUMP_MAP)\n\n          vec3 normal = perturbNormalArb(v_worldPosition, normalize(v_normal));\n\n        #else\n\n          vec3 normal = normalize(v_normal);\n\n        #endif\n\n      #endif\n\n\n\n      if (!gl_FrontFacing) {\n\n        normal = -normal;\n\n      }\n\n\n\n      vec3 diffuseBase = vec3(0.0);\n\n      vec3 specularBase = vec3(0.0);\n\n      // DEBUG:\n\n      // vec3 cascadedColor = vec3(0.0);\n\n      vec3 eyeDirection = normalize(eyeSpacePosition);\n\n\n\n      #if DIRECTION_LIGHT_COUNT\n\n        for (int i = 0; i < DIRECTION_LIGHT_COUNT; i++) {\n\n          DirectionLight light = u_directionLights[i];\n\n          LightInfo info = calculateDirectionLightInfo(light, eyeDirection, normal);\n\n          diffuseBase += info.diffuseColor;\n\n          specularBase += info.specularColor;\n\n          // DEBUG:\n\n          // cascadedColor += info.cascadedColor;\n\n        }\n\n      #endif\n\n      \n\n      #if POINT_LIGHT_COUNT\n\n        for (int i = 0; i < POINT_LIGHT_COUNT; i++) {\n\n          PointLight light = u_pointLights[i];\n\n          LightInfo info = calculatePointLightInfo(light, eyeDirection, normal);\n\n          diffuseBase += info.diffuseColor;\n\n          specularBase += info.specularColor;\n\n        }\n\n      #endif\n\n      \n\n      #if SPOT_LIGHT_COUNT\n\n        for (int i = 0; i < SPOT_LIGHT_COUNT; i++) {\n\n          SpotLight light = u_spotLights[i];\n\n          LightInfo info = calculateSpotLightInfo(light, eyeDirection, normal);\n\n          diffuseBase += info.diffuseColor;\n\n          specularBase += info.specularColor;\n\n        }\n\n      #endif\n\n\n      #ifdef AMBIENT_MAP\n\n        vec3 ambientSamplerColor = texture(u_ambientSampler, v_uv).rgb;\n\n      #else\n\n        vec3 ambientSamplerColor = vec3(1.0);\n\n      #endif\n\n\n\n      #ifdef SPECULAR_MAP\n\n        vec3 specularMaterialColor = texture(u_specularSampler, v_uv).rgb;\n\n      #else\n\n        vec3 specularMaterialColor = u_specularColor;\n\n      #endif\n\n\n\n      diffuseBase += u_ambientColor * u_ambientLightColor;\n\n      diffuseBase *= u_diffuseColor.rgb;\n\n      // DEBUG:\n\n      // diffuseBase += cascadedColor;\n\n      specularBase *= specularMaterialColor;\n\n      vec3 finalColor = diffuseBase;\n\n      finalColor *= baseColor.rgb * ambientSamplerColor;\n\n      finalColor += emissiveColor + specularBase;\n\n      baseColor = vec4(finalColor, u_diffuseColor.a * baseColor.a);\n\n    #else\n\n      baseColor = vec4(u_diffuseColor.rgb * baseColor.rgb + emissiveColor, u_diffuseColor.a * baseColor.a);\n\n    #endif\n\n\n\n    #ifdef ENV_MAP\n\n      #ifdef REFRACTIVE\n\n        vec3 R = refract(-normalize(eyeSpacePosition), normal, 1.0 / 1.52);\n\n      #else\n\n        vec3 R = reflect(-normalize(eyeSpacePosition), normal);\n\n      #endif\n\n      R.x = -R.x;\n\n      // TODO Reflection Map\n\n      baseColor.rgb = mix(baseColor.rgb, baseColor.rgb * gammaInput(texture(u_envSampler, R).rgb), 1.0);\n\n      // baseColor.rgb = gammaInput(texture(u_envSampler, R).rgb);\n\n    #endif\n\n\n\n    baseColor.rgb = gammaOutput(baseColor.rgb);\n\n\n\n    #ifdef WIREFRAME\n\n      fragColor = mix(vec4(u_wireframeColor, u_transparency), baseColor, edgeFactor());\n\n    #else\n\n      fragColor = baseColor;\n\n    #endif\n\n  #endif\n\n\n\n  #ifdef FOG\n\n    float distance = length(eyeSpacePosition);\n\n    float fogFactor = clamp((distance - u_fogNear) / (u_fogFar - u_fogNear), 0.0, 1.0);\n\n    fragColor.rgb = mix(fragColor.rgb, u_fogColor, fogFactor);\n\n  #endif\n}\n\n';

export const PBR_VERTEX_SHADER = '#ifdef MORPH_TARGETS\n\n  #if MORPH_TARGETS_COUNT > 0\n\n    in vec3 a_position0;\n\n  #endif\n\n  #if MORPH_TARGETS_COUNT > 1\n\n    in vec3 a_position1;\n\n  #endif\n\n  #if MORPH_TARGETS_COUNT > 2\n\n    in vec3 a_position2;\n\n  #endif\n\n  #if MORPH_TARGETS_COUNT > 3\n\n    in vec3 a_position3;\n\n  #endif\n\n  uniform float u_weights[MORPH_TARGETS_COUNT];\n\n#endif\n\n\n#ifdef SKIN\n\n  in vec4 a_joint;\n\n  in vec4 a_weight;\n\n  uniform mat4 u_jointMatrix[SKIN_JOINTS_COUNT];\n\n#endif\n\n\n#if defined(LIGHT)\n\n  in vec3 a_normal;\n\n  #ifdef MORPH_TARGETS\n\n    #if MORPH_TARGETS_COUNT > 0\n\n      in vec3 a_normal0;\n\n    #endif\n\n    #if MORPH_TARGETS_COUNT > 1\n\n      in vec3 a_normal1;\n\n    #endif\n\n    #if MORPH_TARGETS_COUNT > 2\n\n      in vec3 a_normal2;\n\n    #endif\n\n    #if MORPH_TARGETS_COUNT > 3\n\n      in vec3 a_normal3;\n\n    #endif\n\n  #endif\n  uniform mat3 u_normalMatrix;\n\n  out vec3 v_normal;\n\n#endif\n\n\n\n#if defined(NORMAL_MAP)\n\n  in vec4 a_tangent;\n\n  out mat3 v_TBN;\n\n  #ifdef MORPH_TARGETS\n\n    #if MORPH_TARGETS_COUNT > 0\n\n      in vec4 a_tangent0;\n\n    #endif\n\n    #if MORPH_TARGETS_COUNT > 1\n\n      in vec4 a_tangent1;\n\n    #endif\n\n    #if MORPH_TARGETS_COUNT > 2\n\n      in vec4 a_tangent2;\n\n    #endif\n\n    #if MORPH_TARGETS_COUNT > 3\n\n      in vec4 a_tangent3;\n\n    #endif\n\n  #endif\n#endif\n\n\n\n#if defined(BASE_COLOR_MAP) || defined(NORMAL_MAP) || defined(EMISSIVE_MAP) || defined(METALLIC_ROUGHNESS_MAP) || defined(OCCLUSION_MAP) || defined(SPECULAR_MAP)\n\n  in vec2 a_uv;\n\n  uniform mat3 u_textureMatrix;\n\n  out vec2 v_uv;\n\n#endif\n\n\n\n#ifdef WIREFRAME\n\n  in vec3 a_barycentric;\n\n  out vec3 v_barycentric;\n\n#endif\n\n\n#if defined(CLIPPLANE) || defined(DIFFUSE_CUBE_MAP)\n\n  out vec3 v_modelPosition;\n\n#endif\n\n\n#if defined(LIGHT) || defined(FOG) || defined(ENV_MAP)\n\n  out vec3 v_worldPosition;\n\n#endif\n\n\n#ifdef VERTEX_COLOR\n\n  in vec4 a_color;\n\n  out vec4 v_color;\n\n#endif\n\n\n#ifdef SHADOW\n\n  #define CASCADED_COUNT 4\n\n  uniform mat4 u_shadowMapProjectViewMatrix_0;\n\n  uniform mat4 u_shadowMapProjectViewMatrix_1;\n\n  uniform mat4 u_shadowMapProjectViewMatrix_2;\n\n  uniform mat4 u_shadowMapProjectViewMatrix_3;\n\n  out vec4 v_shadowMapPosition[CASCADED_COUNT];\n\n#endif\n\n\nin vec3 a_position;\n\nuniform mat4 u_projectViewMatrix;\n\nuniform mat4 u_modelMatrix;\n\n\n\nvoid main () {\n\n  vec3 position = a_position;\n\n\n\n  #ifdef MORPH_TARGETS\n\n    #if MORPH_TARGETS_COUNT > 0\n\n      position += a_position0 * u_weights[0];\n\n    #endif\n\n    #if MORPH_TARGETS_COUNT > 1\n\n      position += a_position1 * u_weights[1];\n\n    #endif\n\n    #if MORPH_TARGETS_COUNT > 2\n\n      position += a_position2 * u_weights[2];\n\n    #endif\n\n    #if MORPH_TARGETS_COUNT > 3\n\n      position += a_position3 * u_weights[3];\n\n    #endif\n\n  #endif\n\n\n  vec4 finalPosition = vec4(position, 1.0);\n\n\n\n  #ifdef SKIN\n\n    mat4 skinMat =\n\n      a_weight.x * u_jointMatrix[int(a_joint.x)] +\n\n      a_weight.y * u_jointMatrix[int(a_joint.y)] +\n\n      a_weight.z * u_jointMatrix[int(a_joint.z)] +\n\n      a_weight.w * u_jointMatrix[int(a_joint.w)];\n\n    finalPosition = skinMat * finalPosition;\n\n  #endif\n\n\n  vec4 worldPosition = u_modelMatrix * finalPosition;\n\n  gl_Position = u_projectViewMatrix * worldPosition;\n\n\n\n  #if defined(LIGHT) || defined(FOG) || defined(ENV_MAP)\n\n    v_worldPosition = worldPosition.xyz;\n\n  #endif\n\n\n  #ifdef SHADOW\n\n    v_shadowMapPosition[0] = u_shadowMapProjectViewMatrix_0 * worldPosition;\n\n    v_shadowMapPosition[1] = u_shadowMapProjectViewMatrix_1 * worldPosition;\n\n    v_shadowMapPosition[2] = u_shadowMapProjectViewMatrix_2 * worldPosition;\n\n    v_shadowMapPosition[3] = u_shadowMapProjectViewMatrix_3 * worldPosition;\n\n  #endif\n\n\n  #if defined(LIGHT)\n\n    vec3 finalNormal = a_normal;\n\n    #ifdef MORPH_TARGETS\n\n      #if MORPH_TARGETS_COUNT > 0\n\n        finalNormal += a_normal0 * u_weights[0];\n\n      #endif\n\n      #if MORPH_TARGETS_COUNT > 1\n\n        finalNormal += a_normal1 * u_weights[1];\n\n      #endif\n\n      #if MORPH_TARGETS_COUNT > 2\n\n        finalNormal += a_normal2 * u_weights[2];\n\n      #endif\n\n      #if MORPH_TARGETS_COUNT > 3\n\n        finalNormal += a_normal3 * u_weights[3];\n\n      #endif\n\n    #endif\n    v_normal = u_normalMatrix * finalNormal;\n\n  #endif\n\n\n\n  #if defined(NORMAL_MAP)\n\n    vec4 finalTangent = a_tangent;\n\n    #ifdef MORPH_TARGETS\n\n      #if MORPH_TARGETS_COUNT > 0\n\n        finalTangent += a_tangent0 * u_weights[0];\n\n      #endif\n\n      #if MORPH_TARGETS_COUNT > 1\n\n        finalTangent += a_tangent1 * u_weights[1];\n\n      #endif\n\n      #if MORPH_TARGETS_COUNT > 2\n\n        finalTangent += a_tangent2 * u_weights[2];\n\n      #endif\n\n      #if MORPH_TARGETS_COUNT > 3\n\n        finalTangent += a_tangent3 * u_weights[3];\n\n      #endif\n\n    #endif\n    vec3 normal = normalize(finalNormal);\n\n    vec3 tangent = normalize(finalTangent.xyz);\n\n    vec3 bitangent = cross(normal, tangent) * finalTangent.w;\n\n    v_TBN = mat3(u_modelMatrix) * mat3(tangent, bitangent, normal);\n  #endif\n\n\n\n  #if defined(BASE_COLOR_MAP) || defined(NORMAL_MAP) || defined(EMISSIVE_MAP) || defined(METALLIC_ROUGHNESS_MAP) || defined(OCCLUSION_MAP) || defined(SPECULAR_MAP)\n\n    #ifdef FLIP_Y\n\n      v_uv = (u_textureMatrix * vec3(a_uv.x, 1.0 - a_uv.y, 1.0)).xy;\n\n    #else\n\n      v_uv = (u_textureMatrix * vec3(a_uv, 1.0)).xy;\n\n    #endif\n\n  #endif\n\n\n\n  #ifdef VERTEX_COLOR\n\n    v_color = a_color;\n\n  #endif\n\n\n  #ifdef WIREFRAME\n\n    v_barycentric = a_barycentric;\n\n  #endif\n\n\n  #if defined(CLIPPLANE) || defined(DIFFUSE_CUBE_MAP)\n\n    v_modelPosition = finalPosition.xyz;\n\n  #endif\n}\n\n';
export const PBR_FRAGMENT_SHADER = 'const float M_PI = 3.141592653589793;\n\nconst float c_minRoughness = 0.04;\n\n\n\n#ifdef PBR_TYPE_METALNESS\n\n  uniform vec4 u_baseColorFactor;\n\n  uniform float u_metallicFactor;\n\n  uniform float u_roughnessFactor;\n\n#endif\n\n\n\n#ifdef PBR_TYPE_SPECULAR\n\n  uniform vec4 u_diffuseFactor;\n\n  uniform vec3 u_specularFactor;\n\n  uniform float u_glossinessFactor;\n\n#endif\n\n\n\nuniform float u_transparency;\n\n\n\n#ifdef VERTEX_COLOR\n\n  in vec4 v_color;\n\n#endif\n\n\n#ifdef BASE_COLOR_MAP\n\n  uniform sampler2D u_baseColorSampler;\n\n#endif\n\n\n\n#ifdef METALLIC_ROUGHNESS_MAP\n\n  #ifdef SEPARATE_METALLIC_ROUGHNESS\n\n    uniform sampler2D u_metallicSampler;\n\n    uniform sampler2D u_roughnessSampler;\n\n  #else\n\n    uniform sampler2D u_metallicRoughnessSampler;\n\n  #endif\n\n#endif\n\n\n\n#ifdef DIFFUSE_MAP\n\n  uniform sampler2D u_diffuseSampler;\n\n#endif\n\n\n\n#ifdef SPECULAR_GLOSSINESS_MAP\n\n  #ifdef SEPARATE_SPECULAR_GLOSSINESS\n\n    uniform sampler2D u_specularSampler;\n\n    uniform sampler2D u_glossinessSampler;\n\n  #else\n\n    uniform sampler2D u_specularGlossinessSampler;\n\n  #endif\n\n#endif\n\n\n\n#if defined(BASE_COLOR_MAP) || defined(NORMAL_MAP) || defined(EMISSIVE_MAP) || defined(METALLIC_ROUGHNESS_MAP) || defined(OCCLUSION_MAP) || defined(SPECULAR_GLOSSINESS_MAP) || defined(DIFFUSE_MAP)\n  in vec2 v_uv;\n\n#endif\n\n\n#if defined(LIGHT)\n\n  in vec3 v_normal;\n\n#endif\n\n\n\n#ifdef OCCLUSION_MAP\n\n  uniform sampler2D u_occlusionSampler;\n\n  uniform float u_occlusionStrength;\n\n#endif\n\n\n\n#ifdef EMISSIVE_MAP\n\n  uniform sampler2D u_emissiveSampler;\n\n  uniform vec3 u_emissiveColor;\n\n#endif\n\n\n\n#if defined(LIGHT) || defined(FOG) || defined(ENV_MAP)\n\n  uniform vec3 u_eyePosition;\n\n  in vec3 v_worldPosition;\n\n#endif\n\n\n#ifdef LIGHT\n\n  #ifdef NORMAL_MAP\n\n    uniform sampler2D u_normalSampler;\n\n    uniform float u_normalScale;\n\n    in mat3 v_TBN;\n\n  #endif\n\n  #ifdef IBL\n\n    uniform samplerCube u_diffuseEnvSampler;\n\n    uniform samplerCube u_specularEnvSampler;\n\n    uniform sampler2D u_brdfLUTSampler;\n\n  #endif\n\n\n\n  #define PCF_SHADOW\n\n  #ifdef SHADOW\n\n    #define CASCADED_COUNT 4\n\n    in vec4 v_shadowMapPosition[CASCADED_COUNT];\n\n    uniform highp sampler2DArrayShadow u_shadowMapSampler;\n\n    uniform vec4 u_cascadedEnd;\n\n  \n\n    float calculateShadow (int layer) {\n\n      vec3 position = v_shadowMapPosition[layer].xyz / v_shadowMapPosition[layer].w;\n\n      position = position * 0.5 + 0.5;\n\n      vec4 shadowUv = vec4(position.xy, float(layer), position.z - 0.005);\n\n  \n\n      #ifdef PCF_SHADOW\n\n        vec2 size = 1.0 / vec2(2048.0, 2048.0);\n\n        float depth = 0.0;\n\n        for (int x = -1; x <= 1; ++x) {\n\n          for (int y = -1; y <= 1; ++y) {\n\n            shadowUv.xy = position.xy + vec2(x, y) * size;\n\n            float pcfDepth = texture(u_shadowMapSampler, shadowUv);\n\n            depth += pcfDepth;\n\n          }\n\n        }\n\n        depth /= 9.0;\n\n        return depth;\n\n      #else\n\n        float depth = texture(u_shadowMapSampler, shadowUv);\n\n        return depth;\n\n      #endif\n\n    }\n\n  #endif\n\n\n  struct LightInfo {\n\n    vec3 diffuseColor;\n\n    vec3 specularColor;\n\n  };\n\n  \n\n  #if DIRECTION_LIGHT_COUNT\n\n    struct DirectionLight {\n\n      vec3 diffuseColor;\n\n      vec3 specularColor;\n\n      vec3 direction;\n\n    };\n\n    uniform DirectionLight u_directionLights[DIRECTION_LIGHT_COUNT];\n\n  \n\n    LightInfo calculateDirectionLightInfo(DirectionLight light, vec3 v, vec3 n, float NdotV,\n\n        vec3 specularEnvironmentR0, vec3 specularEnvironmentR90, float roughnessSq) {\n\n      LightInfo info;\n\n  \n\n      vec3 l = normalize(-light.direction);\n\n      vec3 h = normalize(l+v); // Half vector between both l and v\n\n  \n\n      float NdotL = clamp(dot(n, l), 0.001, 1.0);\n\n      float NdotH = clamp(dot(n, h), 0.0, 1.0);\n\n      float VdotH = clamp(dot(v, h), 0.0, 1.0);\n\n  \n\n      vec3 F = specularEnvironmentR0 + (specularEnvironmentR90 - specularEnvironmentR0) * pow(clamp(1.0 - VdotH, 0.0, 1.0), 5.0);\n\n  \n\n      float attenuationL = 2.0 * NdotL / (NdotL + sqrt(roughnessSq + (1.0 - roughnessSq) * (NdotL * NdotL)));\n\n      float attenuationV = 2.0 * NdotV / (NdotV + sqrt(roughnessSq + (1.0 - roughnessSq) * (NdotV * NdotV)));\n\n      float G = attenuationL * attenuationV;\n\n  \n\n      float f = (NdotH * roughnessSq - NdotH) * NdotH + 1.0;\n\n      float D = roughnessSq / (M_PI * f * f);\n\n  \n\n      // Calculation of analytical lighting contribution\n\n      vec3 diffuse = NdotL * (1.0 - F) * light.diffuseColor;\n\n      vec3 specular = NdotL * F * G * D / NdotL * light.specularColor;\n\n  \n\n      #ifdef SHADOW\n\n        int layer = 3;\n\n        if (gl_FragCoord.z <= u_cascadedEnd.x) {\n\n          layer = 0;\n\n        } else if (gl_FragCoord.z <= u_cascadedEnd.y) {\n\n          layer = 1;\n\n        } else if (gl_FragCoord.z <= u_cascadedEnd.z) {\n\n          layer = 2;\n\n        }\n\n        float shadow = calculateShadow(layer);\n\n        diffuse *= shadow;\n\n        specular *= shadow;\n\n      #endif\n\n  \n\n      info.diffuseColor = light.diffuseColor * diffuse;\n\n      info.specularColor = light.specularColor * specular;\n\n      return info;\n\n    }\n\n  #endif\n\n  \n\n  #if POINT_LIGHT_COUNT\n\n    struct PointLight {\n\n      vec3 diffuseColor;\n\n      vec3 specularColor;\n\n      vec3 position;\n\n      float distance;\n\n    };\n\n    uniform PointLight u_pointLights[POINT_LIGHT_COUNT];\n\n  \n\n    LightInfo calculatePointLightInfo(PointLight light, vec3 v, vec3 n, float NdotV,\n\n        vec3 specularEnvironmentR0, vec3 specularEnvironmentR90, float roughnessSq) {\n\n      LightInfo info;\n\n  \n\n      vec3 l = light.position - v_worldPosition;\n\n      float distance = length(l);\n\n      l = normalize(light.position - v_worldPosition);\n\n      vec3 h = normalize(l+v); // Half vector between both l and v\n\n  \n\n      float NdotL = clamp(dot(n, l), 0.001, 1.0);\n\n      float NdotH = clamp(dot(n, h), 0.0, 1.0);\n\n      float VdotH = clamp(dot(v, h), 0.0, 1.0);\n\n  \n\n      vec3 F = specularEnvironmentR0 + (specularEnvironmentR90 - specularEnvironmentR0) * pow(clamp(1.0 - VdotH, 0.0, 1.0), 5.0);\n\n  \n\n      float attenuationL = 2.0 * NdotL / (NdotL + sqrt(roughnessSq + (1.0 - roughnessSq) * (NdotL * NdotL)));\n\n      float attenuationV = 2.0 * NdotV / (NdotV + sqrt(roughnessSq + (1.0 - roughnessSq) * (NdotV * NdotV)));\n\n      float G = attenuationL * attenuationV;\n\n  \n\n      float f = (NdotH * roughnessSq - NdotH) * NdotH + 1.0;\n\n      float D = roughnessSq / (M_PI * f * f);\n\n  \n\n      // Calculation of analytical lighting contribution\n\n      vec3 diffuse = NdotL * (1.0 - F) * light.diffuseColor;\n\n      vec3 specular = NdotL * F * G * D / NdotL * light.specularColor;\n\n  \n\n      float attenuation = 1.0;\n\n      if (light.distance > 0.0) {\n\n        attenuation = max(1.0 - distance / light.distance, 0.0);\n\n      }\n\n      info.diffuseColor = light.diffuseColor * diffuse * attenuation;\n\n      info.specularColor = light.specularColor * specular * attenuation;\n\n      return info;\n\n    }\n\n  #endif\n\n  \n\n  #if SPOT_LIGHT_COUNT\n\n    struct SpotLight {\n\n      vec3 diffuseColor;\n\n      vec3 specularColor;\n\n      vec3 direction;\n\n      vec3 position;\n\n      float distance;\n\n      float innerAngle;\n\n      float outerAngle;\n\n    };\n\n    uniform SpotLight u_spotLights[SPOT_LIGHT_COUNT];\n\n  \n\n    LightInfo calculateSpotLightInfo(SpotLight light, vec3 v, vec3 n, float NdotV,\n\n        vec3 specularEnvironmentR0, vec3 specularEnvironmentR90, float roughnessSq) {\n\n      LightInfo info;\n\n  \n\n      vec3 l = light.position - v_worldPosition;\n\n      float distance = length(l);\n\n      l = normalize(light.position - v_worldPosition);\n\n      vec3 h = normalize(l+v); // Half vector between both l and v\n\n  \n\n      float NdotL = clamp(dot(n, l), 0.001, 1.0);\n\n      float NdotH = clamp(dot(n, h), 0.0, 1.0);\n\n      float VdotH = clamp(dot(v, h), 0.0, 1.0);\n\n  \n\n      vec3 F = specularEnvironmentR0 + (specularEnvironmentR90 - specularEnvironmentR0) * pow(clamp(1.0 - VdotH, 0.0, 1.0), 5.0);\n\n  \n\n      float attenuationL = 2.0 * NdotL / (NdotL + sqrt(roughnessSq + (1.0 - roughnessSq) * (NdotL * NdotL)));\n\n      float attenuationV = 2.0 * NdotV / (NdotV + sqrt(roughnessSq + (1.0 - roughnessSq) * (NdotV * NdotV)));\n\n      float G = attenuationL * attenuationV;\n\n  \n\n      float f = (NdotH * roughnessSq - NdotH) * NdotH + 1.0;\n\n      float D = roughnessSq / (M_PI * f * f);\n\n  \n\n      // Calculation of analytical lighting contribution\n\n      vec3 diffuse = NdotL * (1.0 - F) * light.diffuseColor;\n\n      vec3 specular = NdotL * F * G * D / NdotL * light.specularColor;\n\n  \n\n      float attenuation = 1.0;\n\n      if (light.distance > 0.0) {\n\n        attenuation = max(1.0 - distance / light.distance, 0.0);\n\n      }\n\n      float theta = dot(l, normalize(-light.direction));\n\n      float epsilon = light.innerAngle - light.outerAngle;\n\n      float intensity = clamp((theta - light.outerAngle) / epsilon, 0.0, 1.0);\n\n      attenuation *= intensity;\n\n      info.diffuseColor = light.diffuseColor * diffuse * attenuation;\n\n      info.specularColor = light.specularColor * specular * attenuation;\n\n      return info;\n\n    }\n\n  #endif\n#endif\n\n\n\n#ifdef WIREFRAME\n\n  uniform vec3 u_wireframeColor;\n\n  uniform float u_wireframeWidth;\n\n  in vec3 v_barycentric;\n\n\n\n  float edgeFactor () {\n\n    vec3 d = fwidth(v_barycentric);\n\n    vec3 a3 = smoothstep(vec3(0.0), d * u_wireframeWidth, v_barycentric);\n\n    return min(min(a3.x, a3.y), a3.z);\n\n  }\n\n#endif\n\n\n#if defined(CLIPPLANE)\n\n  uniform vec4 u_clipPlane;\n\n#endif\n\n\n\n#if defined(CLIPPLANE) || defined(DIFFUSE_CUBE_MAP)\n\n  in vec3 v_modelPosition;\n\n#endif\n\n\n#ifdef FOG\n\n  uniform vec3 u_fogColor;\n\n  uniform float u_fogNear;\n\n  uniform float u_fogFar;\n\n#endif\n\n\n#ifdef ALPHA_TEST\n\n  uniform float u_alphaCutoff;\n\n#endif\n\n\nconst vec3 gammaValue = vec3(2.2);\n\nconst vec3 gammaInvValue = vec3(1.0 / 2.2);\n\n\n\nvec3 gammaInput (vec3 color) {\n\n  #ifdef GAMMA_INPUT\n\n    return pow(color, gammaValue);\n\n  #else\n\n    return color;\n\n  #endif\n\n}\n\n\n\nvec3 gammaOutput (vec3 color) {\n\n  return pow(color, gammaInvValue);\n\n}\n\n\n\n// https://github.com/google/filament/blob/b3d758f3b3fdf91b750a7561a1c729649cf4c1e8/shaders/src/common_graphics.fs\n\nfloat luminance(const vec3 linear) {\n\n  return dot(linear, vec3(0.2126, 0.7152, 0.0722));\n\n}\n\n\n\n// https://github.com/google/filament/blob/b3d758f3b3fdf91b750a7561a1c729649cf4c1e8/shaders/src/tone_mapping.fs\n\nvec3 tonemapACES(const vec3 x) {\n\n  // Narkowicz 2015, "ACES Filmic Tone Mapping Curve"\n\n  const float a = 2.51;\n\n  const float b = 0.03;\n\n  const float c = 2.43;\n\n  const float d = 0.59;\n\n  const float e = 0.14;\n\n  return (x * (a * x + b)) / (x * (c * x + d) + e);\n\n}\n\n\nout vec4 fragColor;\n\n\n\nvoid main () {\n\n  #ifdef CLIPPLANE\n\n    float clipDistance = dot(v_modelPosition, u_clipPlane.xyz);\n\n    if (clipDistance >= u_clipPlane.w) {\n\n      discard;\n\n    }\n\n  #endif\n\n\n  #if defined(LIGHT) || defined(FOG)\n\n    vec3 eyeSpacePosition = u_eyePosition - v_worldPosition;\n\n  #endif\n\n\n\n  #if defined(WIREFRAME) && defined(WIREFRAME_ONLY)\n\n    fragColor = vec4(u_wireframeColor, (1.0 - edgeFactor()) * u_transparency);\n\n  #else\n\n    #ifdef PBR_TYPE_METALNESS\n\n      float metallicFactor = u_metallicFactor;\n\n      float roughnessFactor = u_roughnessFactor;\n\n      #if defined(METALLIC_ROUGHNESS_MAP)\n\n        #ifdef SEPARATE_METALLIC_ROUGHNESS\n\n          metallicFactor *= texture(u_metallicSampler, v_uv).r;\n\n          roughnessFactor *= texture(u_roughnessSampler, v_uv).r;\n\n        #else\n\n          vec4 metallicRoughness = texture(u_metallicRoughnessSampler, v_uv);\n\n          metallicFactor *= metallicRoughness.b;\n\n          roughnessFactor *= metallicRoughness.g;\n\n        #endif\n\n      #endif\n\n\n\n      roughnessFactor = clamp(roughnessFactor, c_minRoughness, 1.0);\n\n      metallicFactor = clamp(metallicFactor, 0.0, 1.0);\n\n      float alphaRoughness = roughnessFactor * roughnessFactor;\n\n      float roughnessSq = alphaRoughness * alphaRoughness;\n\n\n\n      vec4 baseColor = u_baseColorFactor;\n\n      #if defined(BASE_COLOR_MAP)\n\n        vec4 baseColorSamplerColor = texture(u_baseColorSampler, v_uv);\n\n        baseColorSamplerColor.rgb = gammaInput(baseColorSamplerColor.rgb);\n\n        #if defined(BLEND) || defined(ALPHA_TEST)\n\n          baseColor *= baseColorSamplerColor;\n\n        #else\n\n          baseColor.rgb *= baseColorSamplerColor.rgb;\n\n        #endif\n\n      #endif\n\n    #else\n\n      vec4 baseColor = u_diffuseFactor;\n\n      #if defined(DIFFUSE_MAP)\n\n        vec4 diffuseSamplerColor = texture(u_diffuseSampler, v_uv);\n\n        diffuseSamplerColor.rgb = gammaInput(diffuseSamplerColor.rgb);\n\n        #if defined(BLEND) || defined(ALPHA_TEST)\n\n          baseColor *= diffuseSamplerColor;\n\n        #else\n\n          baseColor.rgb *= diffuseSamplerColor.rgb;\n\n        #endif\n\n      #endif\n\n    #endif\n\n\n\n    #ifdef VERTEX_COLOR\n\n      baseColor *= v_color;\n\n    #endif\n\n\n    baseColor.a *= u_transparency;\n\n\n\n    #ifdef ALPHA_TEST\n\n      if (baseColor.a < u_alphaCutoff) {\n\n        discard;\n\n      }\n\n      baseColor.a = 1.0;\n\n    #endif\n\n\n    #ifdef LIGHT\n\n      #ifdef PBR_TYPE_METALNESS\n\n        vec3 f0 = vec3(0.04);\n\n        vec3 diffuseColor = baseColor.rgb * (vec3(1.0) - f0);\n\n        diffuseColor *= 1.0 - metallicFactor;\n\n        vec3 specularColor = mix(f0, baseColor.rgb, metallicFactor);\n\n        float reflectance = max(max(specularColor.r, specularColor.g), specularColor.b);\n\n      #else\n\n        vec3 specularFactor = u_specularFactor;\n\n        float glossinessFactor = u_glossinessFactor;\n\n        #if defined(SPECULAR_GLOSSINESS_MAP)\n\n          #ifdef SEPARATE_SPECULAR_GLOSSINESS\n\n            specularFactor *= gammaInput(texture(u_specularSampler, v_uv).rgb);\n\n            glossinessFactor *= texture(u_glossinessSampler, v_uv).r;\n\n          #else\n\n            vec4 specularGlossinessColor = texture(u_specularGlossinessSampler, v_uv);\n\n            specularFactor *= gammaInput(specularGlossinessColor.rgb);\n\n            glossinessFactor *= specularGlossinessColor.a;\n\n          #endif\n\n        #endif\n\n\n\n        vec3 specularColor = specularFactor;\n\n        // Compute reflectance.\n\n        float reflectance = max(max(specularColor.r, specularColor.g), specularColor.b);\n\n        vec3 diffuseColor = baseColor.rgb * (1.0 - reflectance);\n\n        float roughnessFactor = clamp(1.0 - glossinessFactor, 0.04, 1.0);\n\n        float alphaRoughness = roughnessFactor * roughnessFactor;\n\n        float roughnessSq = alphaRoughness * alphaRoughness;\n\n      #endif\n\n\n\n      // For typical incident reflectance range (between 4% to 100%) set the grazing reflectance to 100% for typical fresnel effect.\n\n      // For very low reflectance range on highly diffuse objects (below 4%), incrementally reduce grazing reflecance to 0%.\n\n      float reflectance90 = clamp(reflectance * 25.0, 0.0, 1.0);\n\n      vec3 specularEnvironmentR0 = specularColor.rgb;\n\n      vec3 specularEnvironmentR90 = vec3(1.0, 1.0, 1.0) * reflectance90;\n\n\n\n      #ifdef NORMAL_MAP\n\n        vec3 normalSampler = (texture(u_normalSampler, v_uv) * 2.0 - 1.0).rgb;\n\n        vec3 n = normalize(normalSampler * vec3(u_normalScale, u_normalScale, 1.0));\n\n        n = normalize(v_TBN * n);\n\n      #else\n\n        vec3 n = normalize(v_normal);\n\n      #endif\n\n\n\n      if (!gl_FrontFacing) {\n\n        n = -n;\n\n      }\n\n\n\n      vec3 v = normalize(eyeSpacePosition);\n\n      vec3 reflection = -normalize(reflect(v, n));\n\n      float NdotV = clamp(abs(dot(n, v)), 0.001, 1.0);\n\n\n\n      vec3 diffuseBase = vec3(0.0);\n\n      vec3 specularBase = vec3(0.0);\n\n\n\n      #if DIRECTION_LIGHT_COUNT\n\n        for (int i = 0; i < DIRECTION_LIGHT_COUNT; i++) {\n\n          DirectionLight light = u_directionLights[i];\n\n          LightInfo info = calculateDirectionLightInfo(light, v, n, NdotV,\n\n            specularEnvironmentR0, specularEnvironmentR90, roughnessSq);\n\n          diffuseBase += info.diffuseColor;\n\n          specularBase += info.specularColor;\n\n        }\n\n      #endif\n\n      \n\n      #if POINT_LIGHT_COUNT\n\n        for (int i = 0; i < POINT_LIGHT_COUNT; i++) {\n\n          PointLight light = u_pointLights[i];\n\n          LightInfo info = calculatePointLightInfo(light, v, n, NdotV,\n\n            specularEnvironmentR0, specularEnvironmentR90, roughnessSq);\n\n          diffuseBase += info.diffuseColor;\n\n          specularBase += info.specularColor;\n\n        }\n\n      #endif\n\n      \n\n      #if SPOT_LIGHT_COUNT\n\n        for (int i = 0; i < SPOT_LIGHT_COUNT; i++) {\n\n          SpotLight light = u_spotLights[i];\n\n          LightInfo info = calculateSpotLightInfo(light, v, n, NdotV,\n\n            specularEnvironmentR0, specularEnvironmentR90, roughnessSq);\n\n          diffuseBase += info.diffuseColor;\n\n          specularBase += info.specularColor;\n\n        }\n\n      #endif\n\n\n      // Calculation of analytical lighting contribution\n\n      vec3 diffuseContrib = diffuseBase * diffuseColor / M_PI;\n\n      vec3 specContrib = specularBase / (4.0 * NdotV);\n\n      vec3 color = diffuseContrib + specContrib;\n\n\n\n      // Calculate lighting contribution from image based lighting source (IBL)\n\n      #ifdef IBL\n\n        vec3 brdf = gammaInput(texture(u_brdfLUTSampler, vec2(NdotV, 1.0 - roughnessFactor)).rgb);\n\n        brdf = gammaInput(brdf);\n\n        vec3 diffuseLight = texture(u_diffuseEnvSampler, n).rgb;\n\n        diffuseLight = gammaInput(diffuseLight);\n\n\n\n        float mipCount = 9.0; // resolution of 512x512\n\n        float lod = (roughnessFactor * mipCount);\n\n        vec3 specularLight = textureLod(u_specularEnvSampler, reflection, lod).rgb;\n\n        specularLight = gammaInput(specularLight);\n\n\n\n        vec3 diffuse = diffuseLight * diffuseColor;\n\n        vec3 specular = specularLight * (specularColor * brdf.x + brdf.y);\n\n\n\n        color += diffuse + specular;\n\n      #endif\n\n    #else\n\n      vec3 color = baseColor.rgb;\n\n    #endif\n\n\n\n    #ifdef OCCLUSION_MAP\n\n      float ao = texture(u_occlusionSampler, v_uv).r;\n\n      color = mix(color, color * ao, u_occlusionStrength);\n\n    #endif\n\n\n\n    #ifdef EMISSIVE_MAP\n\n      vec3 emissive = gammaInput(texture(u_emissiveSampler, v_uv).rgb) * u_emissiveColor;\n\n      color += emissive;\n\n    #endif\n\n\n\n    color = tonemapACES(color);\n\n\n\n    #ifdef WIREFRAME\n\n      fragColor = mix(vec4(u_wireframeColor, u_transparency), gammaOutput(color), edgeFactor());\n\n    #else\n\n      fragColor = vec4(gammaOutput(color), baseColor.a);\n\n    #endif\n\n  #endif\n\n\n\n  #ifdef FOG\n\n    float distance = length(eyeSpacePosition);\n\n    float fogFactor = clamp((distance - u_fogNear) / (u_fogFar - u_fogNear), 0.0, 1.0);\n\n    fragColor.rgb = mix(fragColor.rgb, u_fogColor, fogFactor);\n\n  #endif\n}\n\n';

export const SHADOW_MAP_VERTEX_SHADER = '#ifdef MORPH_TARGETS\n\n  #if MORPH_TARGETS_COUNT > 0\n\n    in vec3 a_position0;\n\n  #endif\n\n  #if MORPH_TARGETS_COUNT > 1\n\n    in vec3 a_position1;\n\n  #endif\n\n  #if MORPH_TARGETS_COUNT > 2\n\n    in vec3 a_position2;\n\n  #endif\n\n  #if MORPH_TARGETS_COUNT > 3\n\n    in vec3 a_position3;\n\n  #endif\n\n  uniform float u_weights[MORPH_TARGETS_COUNT];\n\n#endif\n\n\n#ifdef SKIN\n\n  in vec4 a_joint;\n\n  in vec4 a_weight;\n\n  uniform mat4 u_jointMatrix[SKIN_JOINTS_COUNT];\n\n#endif\n\n\nin vec3 a_position;\n\nuniform mat4 u_projectViewMatrix;\n\nuniform mat4 u_modelMatrix;\n\n\n\nvoid main () {\n\n  vec3 position = a_position;\n\n\n\n  #ifdef MORPH_TARGETS\n\n    #if MORPH_TARGETS_COUNT > 0\n\n      position += a_position0 * u_weights[0];\n\n    #endif\n\n    #if MORPH_TARGETS_COUNT > 1\n\n      position += a_position1 * u_weights[1];\n\n    #endif\n\n    #if MORPH_TARGETS_COUNT > 2\n\n      position += a_position2 * u_weights[2];\n\n    #endif\n\n    #if MORPH_TARGETS_COUNT > 3\n\n      position += a_position3 * u_weights[3];\n\n    #endif\n\n  #endif\n\n\n  vec4 finalPosition = vec4(position, 1.0);\n\n\n\n  #ifdef SKIN\n\n    mat4 skinMat =\n\n      a_weight.x * u_jointMatrix[int(a_joint.x)] +\n\n      a_weight.y * u_jointMatrix[int(a_joint.y)] +\n\n      a_weight.z * u_jointMatrix[int(a_joint.z)] +\n\n      a_weight.w * u_jointMatrix[int(a_joint.w)];\n\n    finalPosition = skinMat * finalPosition;\n\n  #endif\n\n\n  vec4 worldPosition = u_modelMatrix * finalPosition;\n\n  gl_Position = u_projectViewMatrix * worldPosition;\n\n}\n\n';
export const SHADOW_MAP_FRAGMENT_SHADER = 'void main () {\n\n}\n\n';

export const OUTPUT_VERTEX_SHADER = 'in vec3 a_position;\n\nin vec2 a_uv;\n\nout vec2 v_uv;\n\n\n\nvoid main() {\n\n  v_uv = a_uv;\n\n  gl_Position = vec4(a_position, 1.0);\n\n}\n\n';
export const OUTPUT_FRAGMENT_SHADER = 'uniform sampler2D u_sampler;\n\n\n\n// uniform highp sampler2DArray u_sampler;\n\n// uniform float u_layer;\n\n\n\nin vec2 v_uv;\n\nout vec4 fragColor;\n\n\n\nvoid main() {\n\n  fragColor = texture(u_sampler, v_uv);\n\n\n\n  // vec4 color = texture(u_sampler, vec3(v_uv, u_layer));\n\n  // fragColor = vec4(color.r, color.r, color.r, 1.0);\n\n}\n\n';

export const TERRAIN_VERTEX_SHADER = 'in vec3 a_normal;\n\n\n\n#if defined(NORMAL_MAP1) || defined(NORMAL_MAP2) || defined(NORMAL_MAP3)\n\n  in vec4 a_tangent;\n\n  out mat3 v_TBN;\n\n#endif\n\n\n\n#if defined(MIX_MAP) || defined(DIFFUSE_MAP1) || defined(DIFFUSE_MAP2) || defined(DIFFUSE_MAP3) || defined(NORMAL_MAP1) || defined(NORMAL_MAP2) || defined(NORMAL_MAP3)\n\n  in vec2 a_uv;\n\n  out vec2 v_uv;\n\n#endif\n\n\n\n#if defined(LIGHT)\n\n  uniform mat3 u_normalMatrix;\n\n  out vec3 v_normal;\n\n#endif\n\n\n\n#ifdef WIREFRAME\n\n  in vec3 a_barycentric;\n\n  out vec3 v_barycentric;\n\n#endif\n\n\n#if defined(CLIPPLANE) || defined(DIFFUSE_CUBE_MAP)\n\n  out vec3 v_modelPosition;\n\n#endif\n\n\n#if defined(LIGHT) || defined(FOG) || defined(ENV_MAP)\n\n  out vec3 v_worldPosition;\n\n#endif\n\n\n#ifdef VERTEX_COLOR\n\n  in vec4 a_color;\n\n  out vec4 v_color;\n\n#endif\n\n\n#ifdef SHADOW\n\n  #define CASCADED_COUNT 4\n\n  uniform mat4 u_shadowMapProjectViewMatrix_0;\n\n  uniform mat4 u_shadowMapProjectViewMatrix_1;\n\n  uniform mat4 u_shadowMapProjectViewMatrix_2;\n\n  uniform mat4 u_shadowMapProjectViewMatrix_3;\n\n  out vec4 v_shadowMapPosition[CASCADED_COUNT];\n\n#endif\n\n\nin vec3 a_position;\n\nuniform mat4 u_projectViewMatrix;\n\nuniform mat4 u_modelMatrix;\n\n\n\nvoid main () {\n\n  vec3 position = a_position;\n\n  vec4 finalPosition = vec4(position, 1.0);\n\n  vec4 worldPosition = u_modelMatrix * finalPosition;\n\n  gl_Position = u_projectViewMatrix * worldPosition;\n\n\n\n  #if defined(LIGHT) || defined(FOG) || defined(ENV_MAP)\n\n    v_worldPosition = worldPosition.xyz;\n\n  #endif\n\n\n  #ifdef SHADOW\n\n    v_shadowMapPosition[0] = u_shadowMapProjectViewMatrix_0 * worldPosition;\n\n    v_shadowMapPosition[1] = u_shadowMapProjectViewMatrix_1 * worldPosition;\n\n    v_shadowMapPosition[2] = u_shadowMapProjectViewMatrix_2 * worldPosition;\n\n    v_shadowMapPosition[3] = u_shadowMapProjectViewMatrix_3 * worldPosition;\n\n  #endif\n\n\n  #if defined(LIGHT)\n\n    vec3 finalNormal = a_normal;\n\n    v_normal = u_normalMatrix * finalNormal;\n\n  #endif\n\n\n\n  #if defined(NORMAL_MAP1) || defined(NORMAL_MAP2) || defined(NORMAL_MAP3)\n\n    vec4 finalTangent = a_tangent;\n\n    vec3 normal = normalize(finalNormal);\n\n    vec3 tangent = normalize(finalTangent.xyz);\n\n    vec3 bitangent = cross(normal, tangent) * finalTangent.w;\n\n    v_TBN = mat3(u_modelMatrix) * mat3(tangent, bitangent, normal);\n  #endif\n\n\n\n  #if defined(MIX_MAP) || defined(DIFFUSE_MAP1) || defined(DIFFUSE_MAP2) || defined(DIFFUSE_MAP3) || defined(NORMAL_MAP1) || defined(NORMAL_MAP2) || defined(NORMAL_MAP3)\n\n    v_uv = a_uv;\n\n  #endif\n\n\n\n  #ifdef VERTEX_COLOR\n\n    v_color = a_color;\n\n  #endif\n\n\n  #ifdef WIREFRAME\n\n    v_barycentric = a_barycentric;\n\n  #endif\n\n\n  #if defined(CLIPPLANE) || defined(DIFFUSE_CUBE_MAP)\n\n    v_modelPosition = finalPosition.xyz;\n\n  #endif\n}\n\n';
export const TERRAIN_FRAGMENT_SHADER = '#ifdef VERTEX_COLOR\n\n  in vec4 v_color;\n\n#endif\n\n\n#ifdef DIFFUSE_MAP1\n\n  uniform sampler2D u_diffuseSampler1;\n\n#endif\n\n\n\n#ifdef DIFFUSE_MAP2\n\n  uniform sampler2D u_diffuseSampler2;\n\n#endif\n\n\n\n#ifdef DIFFUSE_MAP3\n\n  uniform sampler2D u_diffuseSampler3;\n\n#endif\n\n\n\n#ifdef MIX_MAP\n\n  uniform sampler2D u_mixSampler;\n\n#endif\n\n\n\n#if defined(LIGHT)\n\n  in vec3 v_normal;\n\n#endif\n\n\n\n#if defined(MIX_MAP) || defined(DIFFUSE_MAP1) || defined(DIFFUSE_MAP2) || defined(DIFFUSE_MAP3) || defined(NORMAL_MAP)\n\n  #if defined(MIX_MAP)\n\n    uniform vec2 u_textureScale;\n\n  #endif\n\n  #if defined(DIFFUSE_MAP1)\n\n    uniform vec2 u_textureScale1;\n\n  #endif\n\n  #if defined(DIFFUSE_MAP2)\n\n    uniform vec2 u_textureScale2;\n\n  #endif\n\n  #if defined(DIFFUSE_MAP3)\n\n    uniform vec2 u_textureScale3;\n\n  #endif\n\n  in vec2 v_uv;\n\n#endif\n\n\n\n#if defined(LIGHT) || defined(FOG) || defined(ENV_MAP)\n\n  uniform vec3 u_eyePosition;\n\n  in vec3 v_worldPosition;\n\n#endif\n\n\n#ifdef LIGHT\n\n  uniform float u_shininess;\n\n  uniform vec3 u_specularColor;\n\n\n\n  #ifdef NORMAL_MAP\n\n    #if defined(NORMAL_MAP1)\n\n      uniform sampler2D u_normalSampler1;\n\n    #endif\n\n    #if defined(NORMAL_MAP2)\n\n      uniform sampler2D u_normalSampler2;\n\n    #endif\n\n    #if defined(NORMAL_MAP3)\n\n      uniform sampler2D u_normalSampler3;\n\n    #endif\n\n    in mat3 v_TBN;\n\n  #endif\n\n\n\n  #define PCF_SHADOW\n\n  #ifdef SHADOW\n\n    #define CASCADED_COUNT 4\n\n    in vec4 v_shadowMapPosition[CASCADED_COUNT];\n\n    uniform highp sampler2DArrayShadow u_shadowMapSampler;\n\n    uniform vec4 u_cascadedEnd;\n\n  \n\n    float calculateShadow (int layer) {\n\n      vec3 position = v_shadowMapPosition[layer].xyz / v_shadowMapPosition[layer].w;\n\n      position = position * 0.5 + 0.5;\n\n      vec4 shadowUv = vec4(position.xy, float(layer), position.z - 0.005);\n\n  \n\n      #ifdef PCF_SHADOW\n\n        vec2 size = 1.0 / vec2(2048.0, 2048.0);\n\n        float depth = 0.0;\n\n        for (int x = -1; x <= 1; ++x) {\n\n          for (int y = -1; y <= 1; ++y) {\n\n            shadowUv.xy = position.xy + vec2(x, y) * size;\n\n            float pcfDepth = texture(u_shadowMapSampler, shadowUv);\n\n            depth += pcfDepth;\n\n          }\n\n        }\n\n        depth /= 9.0;\n\n        return depth;\n\n      #else\n\n        float depth = texture(u_shadowMapSampler, shadowUv);\n\n        return depth;\n\n      #endif\n\n    }\n\n  #endif\n\n\n  struct LightInfo {\n\n    vec3 diffuseColor;\n\n    vec3 specularColor;\n\n    // vec3 cascadedColor;\n\n  };\n\n  \n\n  #if DIRECTION_LIGHT_COUNT\n\n    struct DirectionLight {\n\n      vec3 diffuseColor;\n\n      vec3 specularColor;\n\n      vec3 direction;\n\n    };\n\n    uniform DirectionLight u_directionLights[DIRECTION_LIGHT_COUNT];\n\n  \n\n    LightInfo calculateDirectionLightInfo(DirectionLight light, vec3 eyeDirection, vec3 normal) {\n\n      LightInfo info;\n\n      vec3 lightDirection = normalize(-light.direction);\n\n      float ndl = dot(lightDirection, normal);\n\n      float diffuse = max(ndl, 0.0);\n\n      vec3 reflectDirection = reflect(-lightDirection, normal);\n\n      float specular = 0.0;\n\n      if (u_shininess > 0.0) {\n\n        #ifdef NORMAL_MAP\n\n          if (dot(lightDirection, v_normal) > 0.0) {\n\n        #endif\n\n        specular = pow(max(dot(reflectDirection, eyeDirection), 0.0), u_shininess);\n\n        #ifdef NORMAL_MAP\n\n          }\n\n        #endif\n\n      }\n\n  \n\n      #ifdef SHADOW\n\n        int layer = 3;\n\n        // vec3 cascadedColor = vec3(0.0, 0.0, 0.0);\n\n        if (gl_FragCoord.z <= u_cascadedEnd.x) {\n\n          layer = 0;\n\n          // cascadedColor = vec3(0.0, 0.0, 0.2);\n\n        } else if (gl_FragCoord.z <= u_cascadedEnd.y) {\n\n          layer = 1;\n\n          // cascadedColor = vec3(0.0, 0.2, 0.0);\n\n        } else if (gl_FragCoord.z <= u_cascadedEnd.z) {\n\n          layer = 2;\n\n          // cascadedColor = vec3(0.2, 0.0, 0.0);\n\n        }\n\n        float shadow = calculateShadow(layer);\n\n        diffuse *= shadow;\n\n        specular *= shadow;\n\n        // DEBUG:\n\n        // info.cascadedColor = cascadedColor;\n\n      #endif\n\n  \n\n      info.diffuseColor = light.diffuseColor * diffuse;\n\n      info.specularColor = light.specularColor * specular;\n\n      return info;\n\n    }\n\n  #endif\n\n  \n\n  #if POINT_LIGHT_COUNT\n\n    struct PointLight {\n\n      vec3 diffuseColor;\n\n      vec3 specularColor;\n\n      vec3 position;\n\n      float distance;\n\n    };\n\n    uniform PointLight u_pointLights[POINT_LIGHT_COUNT];\n\n  \n\n    LightInfo calculatePointLightInfo(PointLight light, vec3 eyeDirection, vec3 normal) {\n\n      LightInfo info;\n\n      vec3 lightDirection = light.position - v_worldPosition;\n\n      float distance = length(lightDirection);\n\n      lightDirection = normalize(lightDirection);\n\n      float diffuse = max(dot(lightDirection, normal), 0.0);\n\n      vec3 reflectDirection = reflect(-lightDirection, normal);\n\n      float specular = 0.0;\n\n      if (u_shininess > 0.0) {\n\n        #ifdef NORMAL_MAP\n\n          if (dot(lightDirection, v_normal) > 0.0) {\n\n        #endif\n\n        specular = pow(max(dot(reflectDirection, eyeDirection), 0.0), u_shininess);\n\n        #ifdef NORMAL_MAP\n\n          }\n\n        #endif\n\n      }\n\n      float attenuation = 1.0;\n\n      if (light.distance > 0.0) {\n\n        attenuation = max(1.0 - distance / light.distance, 0.0);\n\n      }\n\n      info.diffuseColor = light.diffuseColor * diffuse * attenuation;\n\n      info.specularColor = light.specularColor * specular * attenuation;\n\n      return info;\n\n    }\n\n  #endif\n\n  \n\n  #if SPOT_LIGHT_COUNT\n\n    struct SpotLight {\n\n      vec3 diffuseColor;\n\n      vec3 specularColor;\n\n      vec3 direction;\n\n      vec3 position;\n\n      float distance;\n\n      float innerAngle;\n\n      float outerAngle;\n\n    };\n\n    uniform SpotLight u_spotLights[SPOT_LIGHT_COUNT];\n\n  \n\n    LightInfo calculateSpotLightInfo(SpotLight light, vec3 eyeDirection, vec3 normal) {\n\n      LightInfo info;\n\n      vec3 lightDirection = light.position - v_worldPosition;\n\n      float distance = length(lightDirection);\n\n      lightDirection = normalize(lightDirection);\n\n      float diffuse = max(dot(lightDirection, normal), 0.0);\n\n      vec3 reflectDirection = reflect(-lightDirection, normal);\n\n      float specular = 0.0;\n\n      if (u_shininess > 0.0) {\n\n        #ifdef NORMAL_MAP\n\n          if (dot(lightDirection, v_normal) > 0.0) {\n\n        #endif\n\n        specular = pow(max(dot(reflectDirection, eyeDirection), 0.0), u_shininess);\n\n        #ifdef NORMAL_MAP\n\n          }\n\n        #endif\n\n      }\n\n      float attenuation = 1.0;\n\n      if (light.distance > 0.0) {\n\n        attenuation = max(1.0 - distance / light.distance, 0.0);\n\n      }\n\n      float theta = dot(lightDirection, normalize(-light.direction));\n\n      float epsilon = light.innerAngle - light.outerAngle;\n\n      float intensity = clamp((theta - light.outerAngle) / epsilon, 0.0, 1.0);\n\n      attenuation *= intensity;\n\n      info.diffuseColor = light.diffuseColor * diffuse * attenuation;\n\n      info.specularColor = light.specularColor * specular * attenuation;\n\n      return info;\n\n    }\n\n  #endif\n#endif\n\n\n\n#ifdef WIREFRAME\n\n  uniform vec3 u_wireframeColor;\n\n  uniform float u_wireframeWidth;\n\n  in vec3 v_barycentric;\n\n\n\n  float edgeFactor () {\n\n    vec3 d = fwidth(v_barycentric);\n\n    vec3 a3 = smoothstep(vec3(0.0), d * u_wireframeWidth, v_barycentric);\n\n    return min(min(a3.x, a3.y), a3.z);\n\n  }\n\n#endif\n\n\n#if defined(CLIPPLANE)\n\n  uniform vec4 u_clipPlane;\n\n#endif\n\n\n\n#if defined(CLIPPLANE) || defined(DIFFUSE_CUBE_MAP)\n\n  in vec3 v_modelPosition;\n\n#endif\n\n\n#ifdef FOG\n\n  uniform vec3 u_fogColor;\n\n  uniform float u_fogNear;\n\n  uniform float u_fogFar;\n\n#endif\n\n\nconst vec3 gammaValue = vec3(2.2);\n\nconst vec3 gammaInvValue = vec3(1.0 / 2.2);\n\n\n\nvec3 gammaInput (vec3 color) {\n\n  #ifdef GAMMA_INPUT\n\n    return pow(color, gammaValue);\n\n  #else\n\n    return color;\n\n  #endif\n\n}\n\n\n\nvec3 gammaOutput (vec3 color) {\n\n  return pow(color, gammaInvValue);\n\n}\n\n\n\n// https://github.com/google/filament/blob/b3d758f3b3fdf91b750a7561a1c729649cf4c1e8/shaders/src/common_graphics.fs\n\nfloat luminance(const vec3 linear) {\n\n  return dot(linear, vec3(0.2126, 0.7152, 0.0722));\n\n}\n\n\n\n// https://github.com/google/filament/blob/b3d758f3b3fdf91b750a7561a1c729649cf4c1e8/shaders/src/tone_mapping.fs\n\nvec3 tonemapACES(const vec3 x) {\n\n  // Narkowicz 2015, "ACES Filmic Tone Mapping Curve"\n\n  const float a = 2.51;\n\n  const float b = 0.03;\n\n  const float c = 2.43;\n\n  const float d = 0.59;\n\n  const float e = 0.14;\n\n  return (x * (a * x + b)) / (x * (c * x + d) + e);\n\n}\n\n\n\n\nuniform vec4 u_diffuseColor;\n\nuniform float u_transparency;\n\nout vec4 fragColor;\n\n\n\nvoid main () {\n\n  #ifdef CLIPPLANE\n\n    float clipDistance = dot(v_modelPosition, u_clipPlane.xyz);\n\n    if (clipDistance >= u_clipPlane.w) {\n\n      discard;\n\n    }\n\n  #endif\n\n\n  #if defined(LIGHT) || defined(FOG)\n\n    vec3 eyeSpacePosition = u_eyePosition - v_worldPosition;\n\n  #endif\n\n\n\n  #if defined(WIREFRAME) && defined(WIREFRAME_ONLY)\n\n    fragColor = vec4(u_wireframeColor, (1.0 - edgeFactor()) * u_transparency);\n\n  #else\n\n    #ifdef MIX_MAP\n\n      vec4 mixColor = texture(u_mixSampler, v_uv * u_textureScale);\n\n      vec4 baseColor = mixColor;\n\n      #ifdef DIFFUSE_MAP1\n\n        vec3 diffuseColor1 = texture(u_diffuseSampler1, v_uv * u_textureScale1).rgb;\n\n        diffuseColor1 = gammaInput(diffuseColor1);\n\n      #else\n\n        vec3 diffuseColor1 = vec3(1.0);\n\n      #endif\n\n      #ifdef DIFFUSE_MAP2\n\n        vec3 diffuseColor2 = texture(u_diffuseSampler2, v_uv * u_textureScale2).rgb;\n\n        diffuseColor2 = gammaInput(diffuseColor2);\n\n      #else\n\n        vec3 diffuseColor2 = vec3(1.0);\n\n      #endif\n\n      #ifdef DIFFUSE_MAP3\n\n        vec3 diffuseColor3 = texture(u_diffuseSampler3, v_uv * u_textureScale3).rgb;\n\n        diffuseColor3 = gammaInput(diffuseColor3);\n\n      #else\n\n        vec3 diffuseColor3 = vec3(1.0);\n\n      #endif\n\n      diffuseColor1 *= baseColor.r;\n\n      diffuseColor2 = mix(diffuseColor1, diffuseColor2, baseColor.g);\n\n      baseColor.rgb = mix(diffuseColor2, diffuseColor3, baseColor.b);\n\n    #else\n\n      vec4 baseColor = vec4(1.0);\n\n    #endif\n\n\n\n    #ifdef VERTEX_COLOR\n\n      baseColor *= v_color;\n\n    #endif\n\n\n    baseColor.a *= u_transparency;\n\n\n\n    #ifdef LIGHT\n\n      #ifdef NORMAL_MAP\n\n        #if defined(NORMAL_MAP1)\n\n          vec3 normalColor1 = texture(u_normalSampler1, v_uv * u_textureScale1).rgb;\n\n        #else\n\n          vec3 normalColor1 = vec3(1.0);\n\n        #endif\n\n        #if defined(NORMAL_MAP2)\n\n          vec3 normalColor2 = texture(u_normalSampler2, v_uv * u_textureScale2).rgb;\n\n        #else\n\n          vec3 normalColor2 = vec3(1.0);\n\n        #endif\n\n        #if defined(NORMAL_MAP3)\n\n          vec3 normalColor3 = texture(u_normalSampler3, v_uv * u_textureScale3).rgb;\n\n        #else\n\n          vec3 normalColor3 = vec3(1.0);\n\n        #endif\n\n        normalColor1 *= mixColor.r;\n\n        normalColor2 = mix(normalColor1, normalColor2, mixColor.g);\n\n        vec3 normalColor = mix(normalColor2, normalColor3, mixColor.b);\n\n        vec3 normal = normalize((normalColor * 2.0 - 1.0).rgb);\n\n        normal = normalize(v_TBN * normal);\n\n      #else\n\n        vec3 normal = normalize(v_normal);\n\n      #endif\n\n\n\n      if (!gl_FrontFacing) {\n\n        normal = -normal;\n\n      }\n\n\n\n      vec3 diffuseBase = vec3(0.0);\n\n      vec3 specularBase = vec3(0.0);\n\n      vec3 eyeDirection = normalize(eyeSpacePosition);\n\n\n\n      #if DIRECTION_LIGHT_COUNT\n\n        for (int i = 0; i < DIRECTION_LIGHT_COUNT; i++) {\n\n          DirectionLight light = u_directionLights[i];\n\n          LightInfo info = calculateDirectionLightInfo(light, eyeDirection, normal);\n\n          diffuseBase += info.diffuseColor;\n\n          specularBase += info.specularColor;\n\n          // DEBUG:\n\n          // cascadedColor += info.cascadedColor;\n\n        }\n\n      #endif\n\n      \n\n      #if POINT_LIGHT_COUNT\n\n        for (int i = 0; i < POINT_LIGHT_COUNT; i++) {\n\n          PointLight light = u_pointLights[i];\n\n          LightInfo info = calculatePointLightInfo(light, eyeDirection, normal);\n\n          diffuseBase += info.diffuseColor;\n\n          specularBase += info.specularColor;\n\n        }\n\n      #endif\n\n      \n\n      #if SPOT_LIGHT_COUNT\n\n        for (int i = 0; i < SPOT_LIGHT_COUNT; i++) {\n\n          SpotLight light = u_spotLights[i];\n\n          LightInfo info = calculateSpotLightInfo(light, eyeDirection, normal);\n\n          diffuseBase += info.diffuseColor;\n\n          specularBase += info.specularColor;\n\n        }\n\n      #endif\n\n\n      specularBase *= u_specularColor;\n\n      vec3 finalColor = clamp(diffuseBase * u_diffuseColor.rgb * baseColor.rgb, 0.0, 1.0);\n\n      finalColor += specularBase;\n\n      baseColor = vec4(finalColor, u_diffuseColor.a * baseColor.a);\n\n    #else\n\n      baseColor = vec4(u_diffuseColor.rgb * baseColor.rgb, u_diffuseColor.a * baseColor.a);\n\n    #endif\n\n    baseColor.rgb = gammaOutput(baseColor.rgb);\n\n    #ifdef WIREFRAME\n\n      fragColor = mix(vec4(u_wireframeColor, u_transparency), baseColor, edgeFactor());\n\n    #else\n\n      fragColor = baseColor;\n\n    #endif\n\n  #endif\n\n\n\n  #ifdef FOG\n\n    float distance = length(eyeSpacePosition);\n\n    float fogFactor = clamp((distance - u_fogNear) / (u_fogFar - u_fogNear), 0.0, 1.0);\n\n    fragColor.rgb = mix(fragColor.rgb, u_fogColor, fogFactor);\n\n  #endif\n}\n\n';

export const PICKING_VERTEX_SHADER = '#ifdef MORPH_TARGETS\n\n  #if MORPH_TARGETS_COUNT > 0\n\n    in vec3 a_position0;\n\n  #endif\n\n  #if MORPH_TARGETS_COUNT > 1\n\n    in vec3 a_position1;\n\n  #endif\n\n  #if MORPH_TARGETS_COUNT > 2\n\n    in vec3 a_position2;\n\n  #endif\n\n  #if MORPH_TARGETS_COUNT > 3\n\n    in vec3 a_position3;\n\n  #endif\n\n  uniform float u_weights[MORPH_TARGETS_COUNT];\n\n#endif\n\n\n#ifdef SKIN\n\n  in vec4 a_joint;\n\n  in vec4 a_weight;\n\n  uniform mat4 u_jointMatrix[SKIN_JOINTS_COUNT];\n\n#endif\n\n\nin vec3 a_position;\n\nuniform mat4 u_projectViewMatrix;\n\nuniform mat4 u_modelMatrix;\n\n\n\nvoid main () {\n\n  vec3 position = a_position;\n\n\n\n  #ifdef MORPH_TARGETS\n\n    #if MORPH_TARGETS_COUNT > 0\n\n      position += a_position0 * u_weights[0];\n\n    #endif\n\n    #if MORPH_TARGETS_COUNT > 1\n\n      position += a_position1 * u_weights[1];\n\n    #endif\n\n    #if MORPH_TARGETS_COUNT > 2\n\n      position += a_position2 * u_weights[2];\n\n    #endif\n\n    #if MORPH_TARGETS_COUNT > 3\n\n      position += a_position3 * u_weights[3];\n\n    #endif\n\n  #endif\n\n\n  vec4 finalPosition = vec4(position, 1.0);\n\n\n\n  #ifdef SKIN\n\n    mat4 skinMat =\n\n      a_weight.x * u_jointMatrix[int(a_joint.x)] +\n\n      a_weight.y * u_jointMatrix[int(a_joint.y)] +\n\n      a_weight.z * u_jointMatrix[int(a_joint.z)] +\n\n      a_weight.w * u_jointMatrix[int(a_joint.w)];\n\n    finalPosition = skinMat * finalPosition;\n\n  #endif\n\n\n  vec4 worldPosition = u_modelMatrix * finalPosition;\n\n  gl_Position = u_projectViewMatrix * worldPosition;\n\n}\n\n';
export const PICKING_FRAGMENT_SHADER = 'uniform vec4 u_color;\n\nout vec4 fragColor;\n\n\n\nvoid main () {\n\n  fragColor = u_color;\n\n}\n\n';

export const BILLBOARD_VERTEX_SHADER = '/* uniform vec3 u_cameraRight;\n\nuniform vec3 u_cameraUp;\n\nuniform vec3 u_center;\n\nuniform vec2 u_size;\n\nuniform mat4 u_projectViewMatrix;\n\nin vec3 a_position;\n\n// in vec2 a_uv;\n\n// out vec2 v_uv;\n\n\n\nvoid main() {\n\n  // v_uv = a_uv;\n\n  vec3 worldPosition =\n\n    u_center\n\n    + u_cameraRight * a_position.x * u_size.x\n\n    + u_cameraUp * a_position.y * u_size.y;\n\n  gl_Position = u_projectViewMatrix * vec4(worldPosition, 1.0);\n\n} */\n\n\n\nuniform mat4 u_modelMatrix;\n\nuniform mat4 u_viewMatrix;\n\nuniform mat4 u_projectMatrix;\n\nin vec3 a_position;\n\n// in vec2 a_uv;\n\n// out vec2 v_uv;\n\n\n\nvoid main() {\n\n  mat4 modelViewMatrix = u_viewMatrix * u_modelMatrix;\n\n  // First colunm.\n\n  modelViewMatrix[0][0] = 1.0;\n\n  modelViewMatrix[0][1] = 0.0;\n\n  modelViewMatrix[0][2] = 0.0;\n\n\n\n   // if (spherical == 1) {\n\n    // Second colunm.\n\n    modelViewMatrix[1][0] = 0.0;\n\n    modelViewMatrix[1][1] = 1.0;\n\n    modelViewMatrix[1][2] = 0.0;\n\n  // }\n\n\n\n  // Thrid colunm.\n\n  modelViewMatrix[2][0] = 0.0;\n\n  modelViewMatrix[2][1] = 0.0;\n\n  modelViewMatrix[2][2] = 1.0;\n\n\n\n  gl_Position = u_projectMatrix * modelViewMatrix * vec4(a_position, 1.0);\n\n}\n\n';
export const BILLBOARD_FRAGMENT_SHADER = '// uniform sampler2D u_sampler;\n// in vec2 v_uv;\nout vec4 fragColor;\n\nvoid main() {\n  fragColor = vec4(0.0, 0.0, 1.0, 0.5);\n  // fragColor = texture(u_sampler, v_uv);\n}\n';

export const OUTLINE_VERTEX_SHADER = 'in vec3 a_position;\n\nin vec3 a_normal;\n\n\n\nuniform mat4 u_projectViewMatrix;\n\nuniform mat4 u_modelMatrix;\n\nuniform float u_outlineWidth;\n\nuniform float u_outlineGap;\n\nuniform bool u_outline;\n\n\n\nvoid main() {\n\n  // http://slides.com/xeolabs/silhouettes-in-webgl#/5\n\n  mat4 mvpMatrix = u_projectViewMatrix * u_modelMatrix;\n\n  vec4 position = mvpMatrix * vec4(a_position, 1.0);\n\n  float offset = ((u_outline ? u_outlineWidth : 0.0) + u_outlineGap) * (position.z / 1000.0);\n\n  gl_Position = mvpMatrix * vec4(a_position + a_normal * offset, 1.0);\n\n}';
export const OUTLINE_FRAGMENT_SHADER = 'uniform vec3 u_outlineColor;\n\nout vec4 fragColor;\n\n\n\nvoid main() {\n\n  fragColor = vec4(u_outlineColor, 1.0);\n\n}';

export const GLOW_VERTEX_SHADER = 'in vec3 a_position;\n\nin vec2 a_uv;\n\n\n\nout vec2 v_uv;\n\n\n\nvoid main() {\n\n  v_uv = a_uv;\n\n  gl_Position = vec4(a_position, 1.0);\n\n}';
export const GLOW_FRAGMENT_SHADER = 'uniform sampler2D u_sampler;\n\n\n\nin vec2 v_uv;\n\nout vec4 fragColor;\n\n\n\nvoid main() {\n\n  fragColor = texture(u_sampler, v_uv);\n\n}';

export const GLOW_COLOR_VERTEX_SHADER = 'in vec3 a_position;\n\n\n\nuniform mat4 u_projectViewMatrix;\n\nuniform mat4 u_modelMatrix;\n\n\n\nvoid main() {\n\n  gl_Position = u_projectViewMatrix * u_modelMatrix * vec4(a_position, 1.0);\n\n}';
export const GLOW_COLOR_FRAGMENT_SHADER = 'uniform vec3 u_glowColor;\n\nout vec4 fragColor;\n\n\n\nvoid main() {\n\n  fragColor = vec4(u_glowColor, 1.0);\n\n}';

export const GLOW_BLUR_VERTEX_SHADER = 'in vec3 a_position;\n\nin vec2 a_uv;\n\n\n\nout vec2 v_uv;\n\n\n\nvoid main() {\n\n  v_uv = a_uv;\n\n  gl_Position = vec4(a_position, 1.0);\n\n}';
export const GLOW_BLUR_FRAGMENT_SHADER = 'uniform vec2 u_windowSize;\n\nuniform float u_blurAmount;\n\nuniform float u_blurScale;\n\nuniform float u_blurStrength;\n\nuniform bool u_horizontal;\n\nuniform sampler2D u_sampler;\n\n\n\nin vec2 v_uv;\n\nout vec4 fragColor;\n\n\n\nconst float BLUR_PASSES = 20.0;\n\n\n\nfloat gaussian(float x, float deviation) {\n\n  return (1.0 / sqrt(6.28318530718 * deviation)) * exp(-((x * x) / (2.0 * deviation)));\n\n}\n\n\n\nvoid main() {\n\n  vec4  color     = vec4(0.0);\n\n  float half_blur = u_blurAmount * 0.5;\n\n  float strength  = 1.0 - u_blurStrength;\n\n  float deviation = half_blur * 0.35;\n\n  deviation *= deviation;\n\n\n\n  vec2 texelOffset = u_horizontal ? vec2(u_windowSize.x, 0.0) : vec2(0.0, u_windowSize.y);\n\n\n\n  for (float i = 0.0; i < BLUR_PASSES; i += 1.0) {\n\n    if (i >= u_blurAmount) {\n\n      break;\n\n    }\n\n    float offset = i - half_blur;\n\n    vec4 tex_color = texture(u_sampler, v_uv +\n\n      offset * u_blurScale * texelOffset) * gaussian(offset * strength, deviation);\n\n    color += tex_color;\n\n  }\n\n\n\n  fragColor = clamp(color, 0.0, 1.0);\n\n}';

export const PARTICLE_VERTEX_SHADER = 'uniform float u_pointSize;\n\nuniform mat4 u_projectViewMatrix;\n\n\n\nlayout(location = 0) in vec3 a_position;\n\nlayout(location = 1) in float a_age;\n\nlayout(location = 2) in float a_life;\n\n\n\nout float v_age;\n\nout float v_life;\n\n\n\nvoid main() {\n\n  v_age = a_age;\n\n  v_life = a_life;\n\n  gl_PointSize = u_pointSize + 20.0 * (1.0 - a_age / a_life);\n\n  gl_Position = u_projectViewMatrix * vec4(a_position, 1.0);\n\n}';
export const PARTICLE_FRAGMENT_SHADER = 'uniform vec3 u_pointColor;\n\nuniform sampler2D u_particle;\n\n\n\nin float v_age;\n\nin float v_life;\n\n\n\nout vec4 fragColor;\n\n\n\n// http://iquilezles.org/www/articles/palettes/palettes.htm\n\nvec3 palette(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n\n  return a + b * cos(6.28318 * (c * t + d));\n\n}\n\n\n\nvoid main() {\n\n  float t =  v_age / v_life;\n\n  vec3 color = u_pointColor;\n\n  // color = palette(t,\n\n  //   vec3(0.5, 0.5, 0.5),\n\n  //   vec3(0.5, 0.5, 0.5),\n\n  //   vec3(1.0, 1.0, 1.0),\n\n  //   vec3(0.00, 0.10, 0.20));\n\n  vec4 particleColor = texture(u_particle, gl_PointCoord);\n\n  fragColor = vec4(color, 1.0 - t) * particleColor;\n\n}';

export const PARTICLE_FEEDBACK_VERTEX_SHADER = 'uniform float u_timeDelta;\n\nuniform sampler2D u_rgNoise;\n\nuniform vec2 u_gravity;\n\nuniform vec3 u_origin;\n\nuniform float u_minTheta;\n\nuniform float u_maxTheta;\n\nuniform float u_minSpeed;\n\nuniform float u_maxSpeed;\n\n\n\nlayout(location = 0) in vec3 a_position;\n\nlayout(location = 1) in float a_age;\n\nlayout(location = 2) in float a_life;\n\nlayout(location = 3) in vec2 a_velocity;\n\n\n\nout vec3 v_position;\n\nout float v_age;\n\nout float v_life;\n\nout vec2 v_velocity;\n\n\n\nvoid main() {\n\n  if (a_age >= a_life) {\n\n    ivec2 noise_coord = ivec2(gl_VertexID % 512, gl_VertexID / 512);\n\n    vec2 rand = texelFetch(u_rgNoise, noise_coord, 0).rg;\n\n    float theta = u_minTheta + rand.r*(u_maxTheta - u_minTheta);\n\n    float x = cos(theta);\n\n    float y = sin(theta);\n\n\n\n    v_position = u_origin;\n\n    v_age = 0.0;\n\n    v_life = a_life;\n\n    v_velocity = vec2(x, y) * (u_minSpeed + rand.g * (u_maxSpeed - u_minSpeed));\n\n  } else {\n\n    v_position = a_position + vec3(a_velocity, 0.0) * u_timeDelta;\n\n    v_age = a_age + u_timeDelta;\n\n    v_life = a_life;\n\n    v_velocity = a_velocity + u_gravity * u_timeDelta;\n\n  }\n\n}';
export const PARTICLE_FEEDBACK_FRAGMENT_SHADER = 'void main() {\n\n  discard;\n\n}';
